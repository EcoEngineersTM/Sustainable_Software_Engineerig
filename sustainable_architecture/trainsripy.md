# With modularity against technical debt
Selecting transcript lines in this section will navigate to timestamp in the video

- Modularity is a principle that helps us tackle technical debt at all levels. Let's take a quick look at what modularity actually means in principle and how it relates to our other concepts we have learned in software development. Modularity is about creating self-contained entities that have an interface, an interface through which other units, such as classes or packages or components, use that entity. You could also say that each module should hide its interior and interact with the other modules only through its interface. There are several concepts in computer science that come together with modularity and connect very well with it. One really exciting concept is high cohesion and loose coupling. High cohesion we can think of as a unit, for example, a package, contains different classes that work together to accomplish a task. The classes in the package work together. They have high cohesion. They need nothing or as little as possible from other classes in other packages. They have a loose coupling to the other packages. If this is so, then the package has high cohesion and loose coupling and it is modular or has high modularity. Another concept we have in computer science is called separation of concerns. Separation of concerns basically says the same thing as high cohesion. It just comes from the other side. What doesn't belong together and work together should be separated. And finally, there is the single-responsibility principle by Robert Martin which says that a package or a class should only have one task or one responsibility. So it only changes for one reason, for the one reason of the responsibility that the unit has. Three wonderful statements all pointing in the direction of modularity. We should create units with one task and a narrow interface to other units. How can we implement this in our architecture? Let's imagine we have an architecture that consists of four modules, four quite large modules, one green, one purple, one orange, and a last one blue. In each of these modules, there are, of course, layers, such as interface, application, domain, and infrastructure layer. Then the question is, can I find these modules, these structures, in the software? There are different structuring options that we have in software. The package tree, directory structures, projects, build units, components, depending on which programming language and technology we use. Let me just show you on a package tree how this could look like. I put the colors on the package tree of a system. The upper package is called de for Germany. Below that comes the name of the company, which I have grayed out. Below the package with the company name, the system is divided into four subpackages which in turn contain subpackages. If you look at the colors now, you see there is a green module, a purple one, an orange one, and a blue one. Then you have to wonder, who came up with that? There are two of the purple packages hanging directly under the package with the company name and one under the green upper package, and the orange ones are all over the place under the green and the blue upper package. So the cohesion created by introducing the four different colored modules doesn't carry over to the package tree at all. It would be much better if the structure looked like this. There is clearly a package for each module under the main package. There you will find each module with all its subpackages. This is how the architecture should be transferred to the source code. You should always implement this mapping in your software. This does not have to be on package level. It can also be projects or build units or DLLs, or whatever you want to use to structure your software. That's the kind of thing everybody who wants to have modularity in their source code should pay attention to. What we also always do is measure. So we measure, for example, the size of classes and of methods and also of packages and modules, and there you see interesting things. For example, here is an evaluation of how many files there are with how many lines of code. The measuring tool has a limit between five and 1,000 lines of code, and many files are in this range. Only very few files are larger. You can see them in the diagram. When you see this, you should ask yourself, "Hmm, why are they bigger? Why are there four files in my system that have over 3,761 lines of code?" You should take a look at these classes. These files are different for some reason. This is conspicuous. Or you look at the length of methods. Again, for this system, you can see that most methods have under 100 lines of code, very good work. There are a few outliers that should be looked at more closely, because if a method has a task, then it can't actually get much bigger than the other methods, otherwise the task cut is wrong. One of my favorite metrics is the cyclomatic complexity metric. This is a really old metric from the 60s. This metric measures how many pathways there are through a piece of source code. For the systems studied here, you can see in the evaluation that most methods are in the zero to 10 range. However, there are a few methods that are much more complex. They probably have a whole bunch of if-then-else statements or switch statements, and you wonder if that's really how it's supposed to be. You'd have to make it more modular. So please make sure in your next software project that the modules are reflected in the source code and that your units do not become too big. Compare the size of methods, of classes, the size of packages, and the size of modules, and then you'll be able to spot the parts of your architecture that aren't modular. You will see them in the outliers. I hope you don't feel like these two gentlemen in the comic. One says, "Urgh, didn't you say this system had a nice and clean architecture?" and the other one says, "Of course," and then they look at the screen and the second one says, "You just can't see it now. It's hidden behind the code."

# Design pattern against technical debt

- Design patterns were developed in the late 1990s and are still an excellent means of increasing the speed of reading and understanding source code. If design patterns are used consistently to structure source code, they give us immense advantages in maintenance and further development. First, let's look at a negative example. The other day I was with a colleague looking for a bug in a piece of our software. On the user interface, wrong data was displayed. So we wondered through source code in our system and found quite few patterns we knew well. The user interface is programmed with a model view controller pattern. The controller calls the service to retrieve the new data, and then the controller displays it in the view. This all looked fine. So, the error must be below in the service. So far, so logical, if you know these design patterns, but then what did we discover in the service? The service called a factory class to query the data. The factory pattern is meant to create entities and value objects. Entities and value objects are two types of BusinessObjects introduced by domain-driven design. A factory creates BusinessObjects that are needed in the system. So we looked into this factory class and realized to our horror, oh no, this factory class also calculates something on objects and even processes them further. A factory class is not allowed to do that. At least not if it had been programmed according to the rules described for the factory pattern. My colleague and I sat in front of this staring at the source code, thinking back and forth. What is this? Why is someone calling this class a factory class? Who was that anyway? However, the story goes on. What I want to show you with this story is, this misuse of patterns totally stopped us in our flow looking for the bug. We started to think about what the person who had used the pattern so incorrectly here had intended to do with it. And that's the point. When you use design patterns which you should absolutely do, please use them consistently. Use the right patterns in the right layers. Model view controller belongs in the presentation layer. Services are correct in the application layer, and entities and value objects belong in the domain layer. What patterns do is really outstanding. On the one hand, they strengthening modularity. Each pattern specifies exactly what tasks the class that implements the pattern have to do. A controller processes the input from users, calls the service and provides the data so that the view can display it in turn. The view only displays. That is the task of classes of this pattern. A service will never have a user interface. So each class has a specific responsibility in the system, through its pattern. This totally contributes to modularity. And on the other hand, patterns specify relationships. A controller may work with entities, but a view may never call the controller and much more, the set of allowed relationships is limited by patterns. If you look closely, you can even see that patterns provide hierarchical structures. There are no bottom up calls between these patterns. The entity will never call the controller. This is actually true for almost all patterns. Some patterns that map father-child relationships also allow psychic structures but these are only allowed very locally. So patterns pay not only for modularity, but also for layering. In our analysis of systems, we look at patterns and their relationships just like modularity and layering. Let me show you this with an example. The first thing we do is that we are standing with a development team in front of a Blackboard or right now, in digital times, in front of a mural board. And there we are collecting the patterns that can be found in their system. On the left, you see different patterns written down on a Blackboard. The factory is in the middle. There is the pattern, business object and the utility pattern, quite different patterns and their relationships are shown on the board as well. We then try to map the source code to these patterns. For this, we use an architectural analysis tool that allows us to model structures on the source code. On the right side you can see the result of such a mapping. The rectangles each represent a layer that contains all classes of a pattern. So in this system, there is the service pattern, a process pattern, an importer pattern and so on. At the bottom, there is also a layer each for BusinessObjects, Exceptions, and IDs. Of course we did the sorting of the patterns in this order together with the development team. They have already made it clear on the Blackboard on the left, who is allowed to use whom and have thus specified which pattern layer must go further up and which further down. With the tool, we sort the individual classes of the system finally to these pattern layers. Once the classes are sorted into the pattern layers, the relationships between the classes of these patterns in this system become visible. The green and red arcs on the far right of the diagram, are the relationships between the classes in the pattern layers. There is a lot of green arcs that match exactly the desired pattern layering. And there are a few red arcs that represent the violations of the pattern layering. Overall,this system has only 0.1% of relationships running against the pattern layering. This is a very good result. The red arcs, which are the violations of pattern layering, we have been investigating them with the development team to see if the patterns are being used correctly or how to fix these violations. Also, the great thing about this system is that we were able to assign 90% of the source code to the patterns. This is an excellent value. If we can match less source code to patterns then, the rest is usually in very poor condition. I hope that in this video I could make you understand how valuable design patterns are. Please use your patterns consistently because wrong patterns will slow down your developers. If they use the patterns correctly and consistently ,then your development team will be faster. I hope you don't feel the same way as the two in this comic. The comic is called, "Best practices in application architecture" and it's subtitled, "Today: Use layers to decouple." One geek says to the other, "And every year we mount a new layer to decouple us from the crap we've done the year before." But under the comic, is the most beautiful thing, "Annual rings." So the software has annual rings. We don't want that. We don't want annual rings of patterns. We want consistent use of patterns.

# Cycles create technical debt

- Cycles are drivers of technical debt. They increase coupling in the source code, and the architecture while decreasing coercion. The system loses modularity is significantly due to cycles. The rectangles are all classes. All together, you can see 147 classes from different modules. The affiliation to the respective module can be seen by the color. In the lower area, there are 119 classes in a class cycle. That is they all need each other. You can't take out any class because they are all connected. You can get from any class to any other class in that cycle via other relationships. When I saw that, I said to this service provider, "Oh, please. This is not good for maintenance. See that the development team sorts these classes that they determine which module should use which other without there being a cycle in there. Get rid of the cycle." That's when the service provider said, "Oh, yeah. We love to do that if you pay for it." The answer of my client was, "We have ordered good software. We are not going to pay for their technical debt now." And so time went by, the system was further developed, and after two years, I was allowed to look into the software again, and the system had grown in this way. Meanwhile, 327 classes from eight different modules were linked together in one big class cycle. And this is exactly what happens when you don't take care of the small cycles. The amount of classes in such a cycle gets bigger and bigger. I always say, cycles are like black holes. They suck in classes. You can see that also in the center of this diagram, it is completely black there because the classes in the center have so many relationship with each other. That once sees the black arrows only as a black area. What a high coupling. I have another example of how it comes to something like this. Again, you see rectangles representing classes, and the arrows are their relationships to each other. Some arrows are blue because those are double arrows. So two classes that use each other directly in both directions. On the left side in the center, you see a yellow-colored class. The plugin manager, and around the plugin manager are the other classes. The script command. The load command. The list command. And so on. The blue double arrows between plugin manager, and the other classes make it clear that the plugin manager knows all the command arranged around it, and the commands themself know the manager. This is something you find often in old systems that would develop before dependency injection existed. If this is a local cycle, then you can just leave it as it is. The problem in this cycle is more on the right side. If you go all the way to the right, you will find the plugin properties class Plugin properties sounds like a class where you can pick up properties. that is a class that is called from anywhere in the system. This is also the case here. Quite a few relationships run to the class, plugin properties. Only one red call goes out of plugin properties to a class at the bottom called property helper. And through that one call, and through property helper using plugin manager, the big cycle of all those classes is created. What happened here? Well, there are some helper methods in property helper. And when the plugin properties class was programmed, such a helper method was needed. Then the programmer simply called the helper class. The problem is that it is not clear what role a helper class should have in a system. Helper is a very fuzzy design pattern, and the name sounds so harmless. In the end helper is just the new tool. If we use helper classes in our architecture, we should define what they are allowed to do, and who is allowed to call them as with all design patterns. And now I have a much bigger example for you. We were once asked to look at a system with 9 million lines of code. So quite large. My first question was, how many build units do you have? And I was told 128, which is a bit low for such a large system. So the first thing we did is we measured how many classes are in which build unit. And here you see the result on a pie chart. And if you look at it like this, you realize, wow. There is a build unit with 9,240 classes. That's really a lot. Often, a whole system has that many classes. And if you look at the lines of code of this build unit, there are 3 million lines of code in this one built unit. So one third of the whole system. That's suspicious. So we looked inside, and there we found something I've never seen anything like this before. A huge cycle with 5,270 classes all in one build unit, and so strongly coupled that you only see a large area of classes. I then asked the architect, "Oh, my. What are you doing with that? How do you maintain that? How do you even expand that?" He looked at me in consternation, and said to me, "We are not touching that at all. That's way too dangerous. Look, we built an interface. The classes on the left in purple are the interface." I can very well will understand that this is the current solution to get along with this thing, but in the long-run, however, you will have to refactor this big ball of mud or you will have to re-implement it. After all, software needs to evolve to adapt, to check change in the application domain. In both cases, this will be a lot of work. I hope I was able to convey to you a little bit that cycles grow if you don't take care of them. Use the patterns you have in your system correctly because otherwise, it will lead to even more cycles. Besides, cycles prevent your system from becoming modular because all elements in a cycle need each other, so they can't be split into several modules. Cycles often cause situations like the one shown in the comic on the right. One geek says, "I cannot reproduce the bugs from yesterday." And then they look at each other, and the other one says, "Maybe a time-space discontinuity has come by and moved us into a parallel universe where this bug has never existed." And the first one says, "Sounds reasonable. I closed this ticket." => no!

# Architecture reviews against technical debt

- [Instructor] To find out the condition of a software system or an entire IT landscape, management often commissions audits or reviews. These comprehensive reviews or audits are often about technical depth in the source code, but also about technical depth in databases and the design of interfaces. Often, theses reviews are also about organizational weaknesses in the development process, or the structure and processes of the IT organization. To get the most complete picture of the problem situation here, you should search broadly. To get as much information as possible about trouble spots and problems, we start such comprehensive reviews with interviews where we interview all involved stakeholders responsible for the software for about half an hour. Here, we usually learn quite a lot of things that are only hinted in the original assignment, or that are completely unknown to the management. Finally, of course, metrics and analysis tools are used to make a sound assessment of the interviewees' and management's perceptions of the problematic corners. Typically, a review with architecture analysis proceeds as follows. First, the review team conducts interviews with at least one architect or selected members of the development team to learn about the situation and perceived problems. These interviews are locked, and locks are fed back to the interviewees. In addition, the review team is provided with documents by the client, such as the architecture documentation, coding guidelines, and test coverage documentation. Armed with all this information, the analysis workshop is then conducted. This involves importing the source code into an architecture analysis tool and discussing the structure found together with the development team and the architects of the system. During the analysis workshop, the review team works out different architecture views with the development team and the tool, and considers refactorings for the violations visible there. Based on the result, the review team then creates a quality report, and hands it over to the client together with the prioritized refactorings. The basis for the evaluation are the three architectural principles, modularity, layering, and pattern consistency, which are based on structure-building processes from cognitive signs, chunking, hierarchies, and schemata, which we learned about in part three of this series. Here, for modularity, we look at whether classes, packages, and modules have clear responsibilities, how strongly they are coupled, whether they are outliers in size, and how the interfaces are designed. In layering, we examine cycles at the class package and module level, and finally look at how the teams use patterns. Are patterns used consistently and uniformly? We condense all these criteria into a single number, the Modularity Maturity Index or MMI. This index makes it clear whether an architecture has a modular structure, and is therefore a maintainable and extendable architecture. The MMI ranks systems on a scale from zero to 10. Systems that have a score between zero and four are in poor condition. Systems between four and eight are in mediocre condition. And systems between eight and 10 are in very good condition. Here, you can see 18 systems that we evaluated with the MMI. On the x-axis, each system has a unit. And by the size of the bubbles, you can see how large the systems are in comparison. You will find systems in all possible programming languages. There is a big system with 14 million lines of code in the front-left. It is in a really good condition. This is a Java system. Also, this small one in the middle is a Java system, but it is in very bad condition. And also, this small one here in the middle is Java. This system, on the other hand, is implemented in C#. Actually, I thought there were no major C# systems until a customer sent us to Romania to an SAP competitor. There, we found a nearly 10 million lines of code, huge C# system, which was a very high quality. You see, the size of the system, the programming language, none of this is a reason for a good result in the MMI, but the modularity of the architecture that the development team has built. If you are unsure for your current project how good or how bad the development is, then a well-targeted review could help to give confidence to the development team and show new or better ways to implement things. In particular, a comparison with other systems and the current state of the art will help your teams on their way to sustainable software architecture. I hope you haven't fallen into the trap of detailed documentation, like the two gentlemen in this comic. One of them says, "What are you writing?" And the other one answers, "A requirement specification and technical design test cases system and user documentation." After thinking for a moment, the first one says, "Audit coming?" And the other one says, "Yep, tomorrow." This is not the solution after all. Please come to a review without a lot of work, and just show us what you have.
