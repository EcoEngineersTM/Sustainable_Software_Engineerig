# With modularity against technical debt
Selecting transcript lines in this section will navigate to timestamp in the video

- Modularity is a principle that helps us tackle technical debt at all levels. Let's take a quick look at what modularity actually means in principle and how it relates to our other concepts we have learned in software development. Modularity is about creating self-contained entities that have an interface, an interface through which other units, such as classes or packages or components, use that entity. You could also say that each module should hide its interior and interact with the other modules only through its interface. There are several concepts in computer science that come together with modularity and connect very well with it. One really exciting concept is high cohesion and loose coupling. High cohesion we can think of as a unit, for example, a package, contains different classes that work together to accomplish a task. The classes in the package work together. They have high cohesion. They need nothing or as little as possible from other classes in other packages. They have a loose coupling to the other packages. If this is so, then the package has high cohesion and loose coupling and it is modular or has high modularity. Another concept we have in computer science is called separation of concerns. Separation of concerns basically says the same thing as high cohesion. It just comes from the other side. What doesn't belong together and work together should be separated. And finally, there is the single-responsibility principle by Robert Martin which says that a package or a class should only have one task or one responsibility. So it only changes for one reason, for the one reason of the responsibility that the unit has. Three wonderful statements all pointing in the direction of modularity. We should create units with one task and a narrow interface to other units. How can we implement this in our architecture? Let's imagine we have an architecture that consists of four modules, four quite large modules, one green, one purple, one orange, and a last one blue. In each of these modules, there are, of course, layers, such as interface, application, domain, and infrastructure layer. Then the question is, can I find these modules, these structures, in the software? There are different structuring options that we have in software. The package tree, directory structures, projects, build units, components, depending on which programming language and technology we use. Let me just show you on a package tree how this could look like. I put the colors on the package tree of a system. The upper package is called de for Germany. Below that comes the name of the company, which I have grayed out. Below the package with the company name, the system is divided into four subpackages which in turn contain subpackages. If you look at the colors now, you see there is a green module, a purple one, an orange one, and a blue one. Then you have to wonder, who came up with that? There are two of the purple packages hanging directly under the package with the company name and one under the green upper package, and the orange ones are all over the place under the green and the blue upper package. So the cohesion created by introducing the four different colored modules doesn't carry over to the package tree at all. It would be much better if the structure looked like this. There is clearly a package for each module under the main package. There you will find each module with all its subpackages. This is how the architecture should be transferred to the source code. You should always implement this mapping in your software. This does not have to be on package level. It can also be projects or build units or DLLs, or whatever you want to use to structure your software. That's the kind of thing everybody who wants to have modularity in their source code should pay attention to. What we also always do is measure. So we measure, for example, the size of classes and of methods and also of packages and modules, and there you see interesting things. For example, here is an evaluation of how many files there are with how many lines of code. The measuring tool has a limit between five and 1,000 lines of code, and many files are in this range. Only very few files are larger. You can see them in the diagram. When you see this, you should ask yourself, "Hmm, why are they bigger? Why are there four files in my system that have over 3,761 lines of code?" You should take a look at these classes. These files are different for some reason. This is conspicuous. Or you look at the length of methods. Again, for this system, you can see that most methods have under 100 lines of code, very good work. There are a few outliers that should be looked at more closely, because if a method has a task, then it can't actually get much bigger than the other methods, otherwise the task cut is wrong. One of my favorite metrics is the cyclomatic complexity metric. This is a really old metric from the 60s. This metric measures how many pathways there are through a piece of source code. For the systems studied here, you can see in the evaluation that most methods are in the zero to 10 range. However, there are a few methods that are much more complex. They probably have a whole bunch of if-then-else statements or switch statements, and you wonder if that's really how it's supposed to be. You'd have to make it more modular. So please make sure in your next software project that the modules are reflected in the source code and that your units do not become too big. Compare the size of methods, of classes, the size of packages, and the size of modules, and then you'll be able to spot the parts of your architecture that aren't modular. You will see them in the outliers. I hope you don't feel like these two gentlemen in the comic. One says, "Urgh, didn't you say this system had a nice and clean architecture?" and the other one says, "Of course," and then they look at the screen and the second one says, "You just can't see it now. It's hidden behind the code."

# Design pattern against technical debt

- Design patterns were developed in the late 1990s and are still an excellent means of increasing the speed of reading and understanding source code. If design patterns are used consistently to structure source code, they give us immense advantages in maintenance and further development. First, let's look at a negative example. The other day I was with a colleague looking for a bug in a piece of our software. On the user interface, wrong data was displayed. So we wondered through source code in our system and found quite few patterns we knew well. The user interface is programmed with a model view controller pattern. The controller calls the service to retrieve the new data, and then the controller displays it in the view. This all looked fine. So, the error must be below in the service. So far, so logical, if you know these design patterns, but then what did we discover in the service? The service called a factory class to query the data. The factory pattern is meant to create entities and value objects. Entities and value objects are two types of BusinessObjects introduced by domain-driven design. A factory creates BusinessObjects that are needed in the system. So we looked into this factory class and realized to our horror, oh no, this factory class also calculates something on objects and even processes them further. A factory class is not allowed to do that. At least not if it had been programmed according to the rules described for the factory pattern. My colleague and I sat in front of this staring at the source code, thinking back and forth. What is this? Why is someone calling this class a factory class? Who was that anyway? However, the story goes on. What I want to show you with this story is, this misuse of patterns totally stopped us in our flow looking for the bug. We started to think about what the person who had used the pattern so incorrectly here had intended to do with it. And that's the point. When you use design patterns which you should absolutely do, please use them consistently. Use the right patterns in the right layers. Model view controller belongs in the presentation layer. Services are correct in the application layer, and entities and value objects belong in the domain layer. What patterns do is really outstanding. On the one hand, they strengthening modularity. Each pattern specifies exactly what tasks the class that implements the pattern have to do. A controller processes the input from users, calls the service and provides the data so that the view can display it in turn. The view only displays. That is the task of classes of this pattern. A service will never have a user interface. So each class has a specific responsibility in the system, through its pattern. This totally contributes to modularity. And on the other hand, patterns specify relationships. A controller may work with entities, but a view may never call the controller and much more, the set of allowed relationships is limited by patterns. If you look closely, you can even see that patterns provide hierarchical structures. There are no bottom up calls between these patterns. The entity will never call the controller. This is actually true for almost all patterns. Some patterns that map father-child relationships also allow psychic structures but these are only allowed very locally. So patterns pay not only for modularity, but also for layering. In our analysis of systems, we look at patterns and their relationships just like modularity and layering. Let me show you this with an example. The first thing we do is that we are standing with a development team in front of a Blackboard or right now, in digital times, in front of a mural board. And there we are collecting the patterns that can be found in their system. On the left, you see different patterns written down on a Blackboard. The factory is in the middle. There is the pattern, business object and the utility pattern, quite different patterns and their relationships are shown on the board as well. We then try to map the source code to these patterns. For this, we use an architectural analysis tool that allows us to model structures on the source code. On the right side you can see the result of such a mapping. The rectangles each represent a layer that contains all classes of a pattern. So in this system, there is the service pattern, a process pattern, an importer pattern and so on. At the bottom, there is also a layer each for BusinessObjects, Exceptions, and IDs. Of course we did the sorting of the patterns in this order together with the development team. They have already made it clear on the Blackboard on the left, who is allowed to use whom and have thus specified which pattern layer must go further up and which further down. With the tool, we sort the individual classes of the system finally to these pattern layers. Once the classes are sorted into the pattern layers, the relationships between the classes of these patterns in this system become visible. The green and red arcs on the far right of the diagram, are the relationships between the classes in the pattern layers. There is a lot of green arcs that match exactly the desired pattern layering. And there are a few red arcs that represent the violations of the pattern layering. Overall,this system has only 0.1% of relationships running against the pattern layering. This is a very good result. The red arcs, which are the violations of pattern layering, we have been investigating them with the development team to see if the patterns are being used correctly or how to fix these violations. Also, the great thing about this system is that we were able to assign 90% of the source code to the patterns. This is an excellent value. If we can match less source code to patterns then, the rest is usually in very poor condition. I hope that in this video I could make you understand how valuable design patterns are. Please use your patterns consistently because wrong patterns will slow down your developers. If they use the patterns correctly and consistently ,then your development team will be faster. I hope you don't feel the same way as the two in this comic. The comic is called, "Best practices in application architecture" and it's subtitled, "Today: Use layers to decouple." One geek says to the other, "And every year we mount a new layer to decouple us from the crap we've done the year before." But under the comic, is the most beautiful thing, "Annual rings." So the software has annual rings. We don't want that. We don't want annual rings of patterns. We want consistent use of patterns.
